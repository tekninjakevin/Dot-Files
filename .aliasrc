
############################################################################
#    :::    :::       :::::::::::    :::     :::::::: :::::::::  ::::::::
#  :+: :+:  :+:           :+:      :+: :+:  :+:    :+::+:    :+::+:    :+:
# +:+   +:+ +:+           +:+     +:+   +:+ +:+       +:+    +:++:+
#+#++:++#++:+#+           +#+    +#++:++#++:+#++:++#+++#++:++#: +#+
#+#+     +#++#+           +#+    +#+     +#+       +#++#+    +#++#+
##+#     #+##+#           #+#    #+#     #+##+#    #+##+#    #+##+#    #+#
####     ###########################     ### ######## ###    ### ########
############################################################################
# Aliasrc Version 5.0
# To use Source form Bashrc or Zshrc Example source ~/.alaisrc
# Author: Kevin Tangreen Aka TekNinja78
# Email: Spidermankevin78@gmail.com
# Last Update: Thu 25 Aug 2022 05:14:46 PM CDT  
# License: © 2019 WTFPL - http://www.wtfpl.net/
##########################ALIAS#############################################
#!/usr/bin/zsh
#=============Common Options for Common Caomands=============={{{
alias rm='rm -Ivr'
alias cp='cp -aivr'
alias mv='mv -iv'
alias du='du -h'
alias df='df -Th  --total'
alias mkdir='mkdir -v -p'
alias rmdir='rmdir -v'
alias ln='ln -v -i'
alias wget='wget -N -c'
alias pdfgrep='pdfgrep -in'
alias free="free -h"
alias chmod='chmod -c'
alias chown='chown -c'
alias grep='grep --color=auto --exclude-dir={.git,.svn}'
alias egrep='egrep --color=auto --exclude-dir={.git,.svn}'
alias surfraw='surfraw -browser=$BROWSERCLI'

alias sr='surfraw -browser=$BROWSER'		# open in gui browser
alias lsblk='lsblk -o "KNAME,HOTPLUG,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID,MODEL,SERIAL"'
alias diff='diff --color=auto'
alias inxi='inxi -Fxzc2'			#See System info
alias gitu='git add . && git commit && git push'
alias emacs="/usr/bin/emacs-26.1 -nw"
alias visudo='sudo EDITOR="$EDITOR" visudo'

alias cal3='cal -3 | grep -B6 -A6 --color -e " $(date +%e)" -e "^$(date +%e)"' # show calendar for 3 months
#=============================================================}}}
#=============LS Aliases======================================{{{
#use exa instead ls

alias lx="exa --color=always --group-directories-first"

alias ll="exa -lF --group-directories-first"				# List all Files in long format.
alias la="ls -alF" 				#long format hidden allso
alias lh="ls -a"			#show hidden files and diractores
alias lsd="ls -lF | grep '^d'" 			# List only directories
alias lx='ls -lxb'				# Sort file by extinsion
alias lk='ls -ls'				# Sort By Size
alias lc='ls -lc'				# Sort by Change Time
alias lu='ls -lu'				# Sort by access time
alias lr='ls -lR| more'				# Recursive ls
alias lm='ls -al |most'				# Ls + most
lsg() {
  keyword=$(echo "$@" |  sed 's/ /.*/g')
  ls -hlA --color=yes \
  | awk '{k=0;for(i=0;i<=8;i++)k+=((substr($1,i+2,1)~/[rwx]/)*2^(8-i));if(k)printf(" %0o ",k);print}' \
  | grep -iE $keyword
}
#=============================================================}}}
#=============Shortcuts======================================={{{
alias comics='~/Comic_books/'
alias schems='/usr/share/glib-2.0/schemas/'
alias pics='cd ~/Pictures'
alias torrents='cd ~/Torrents'
alias videos='cd ~/Videos'
alias walls='cd ~/Pictures/Wallpaper'
alias roms='cd /media/DataFiles/Roms'
alias docs='/usr/share/doc/'
alias notes='cd ~/Notes/'
alias music='cd ~/Music'
alias movies='cd ~/Movies/'
alias projects='cd ~/projects'
alias Vynil='scim $DOC/Spreed_Sheets/MusicCollection.sc'
alias comiclist='sc-im $DOC/Spreed_Sheets/Comic_Book_Collection.sc'
alias spreedsheets='cd $DOC/Spreed_Sheets'
alias wiki='nvim ~/vimwiki/index.wiki'
#=============================================================}}}
#=============Personal Commands==============================={{{

#exit Terminal
alias q="exit"
#Editor Command Requares Neovim or use Editor of you choice
#alias nvim="Nvim"
alias edit="Nvim"
alias e='Nvim'
alias sedit="sudo Nvim"
#Start ranger fm Short for FileManager Requires Ranger
alias fm="ranger"
alias sfm="sudo ranger"
#Requires rifle part of Ranger or use xdg-open
alias open='rifle'
#New Empty
alias new='touch'
alias playCD='mpv /dev/sr0'
#Super User Short Cut
alias SS='sudo'
# What the fuck
alias wtf='dmesg'
# Make hstr less typing Requires hstr
alias hh='hstr'
#NewsBoat Shortcut Requires news boat
alias news='newsboat'
#Requires espeak
alias say="espeak"
#Kill All Applacations
alias ka="killall"
#make a new dirctory
alias mkd='mkdir'
#Mounting Comand
    alias pmount='udisksctl mount -b'
#Add item to tado listing Requires Taskwarrior
alias chuck='fortune -a chucknorris|lolcat'
alias cowchuck='fortune -a chucknorris|cowthink|lolcat'
alias chucksay='chuck'
alias apt-get="sodo apt-get"
alias install="sudo apt-get install"


function cpv() {
    rsync -pogbr -hhh --backup-dir=/tmp/rsync -e /dev/null --progress "$@"
}
function ta() {
	task add "$1"
	task list
}
alias Ta="ta"
alias te="task edit"
function tl() {

 echo ""
                echo "     ██                 ██"
                echo "    ░██                ░██"
                echo "   ██████  ██████   ██████  ██████"
                echo "  ░░░██  ░██░░░░██░██░░░██░██   ░██"
                echo "    ░██  ░██   ░██░██  ░██░██   ░██"
                echo "    ░░██ ░░██████ ░░██████░░██████"
                echo "     ░░   ░░░░░░   ░░░░░░  ░░░░░░"
                echo ""
                echo "     _ __ __________________ __ _"
                echo ""
task list
}
alias lt="tl"
function td() {
    task "$1" done
    task list
}
alias Data_use="vnstati -vs -i wlp3s0 -o ~/summary.png"  
function te() {task "$1" edit}
#Remind Shortcuts Requires remind
alias 2w='remind -ccu+2 -w100 ~/.remind'
alias 1m='remind -c1 -w100 ~/.remind'
alias musicplayer="ncmpcpp"
#Mixer Requarse ncpamixer
alias pamixer="ncpamixer"
# Firefox
#alias firefox='/opt/firefox/firefox'
alias wttr='curl wttr.in'                               # wego weather forcast using only curl
#alias chrome='/opt/chrome/chrome'
alias clean_tmp="sudo rm -r magi*" 
alias mutt="neomutt"
alias wine3="/opt/Proton3/dist/bin/wine" 
alias wine4="/opt/proton_dist42/vbin/iwine "
alias wine7=""
alias synaptic="sudo synaptic" 
alias movieserver="gerbera -a ~/Movies"

alias sexytime="mpv /media/DataFiles/Music/Music_Archives/10_Mixed_Genra_Compulations/1980\'s/41.\ Marvin\ Gaye\ -\ Sexual\ Healing\ \(January\ 1983\)\ -\ \(www.SongsLover.pk\).mp3"


#==============================================================}}}
#=============Configurations Reload==========================={{{
#------------------------------------------------------
rld-bashrc() { source ~/.bashrc ;}
rld-font() { fc-cache -v -f ;}
rld-grub() { sudo grub-mkconfig -o /boot/grub/grub.cfg ;}
rld-updatedb() { sudo updatedb ;}
rld-xdefaults() { xrdb ~/.Xdefaults ;}
rld-xmodmap() { xmodmap ~/.Xmodmap ;}
rld-xresources() { xrdb -load ~/.Xresources ;}
rld-zshrc() { source ~/.zshrc ;}
#=============================================================}}}
#=============Pacman aliases=================================={{{
#if necessary, replace 'pacman' with your favorite AUR helper and adapt the commands accordingly
alias pac="sudo /usr/bin/pacman -S"             # default action        - install one or more packages
alias pacu="/usr/bin/pacman -Syu"               # '[u]pdate'            - upgrade all packages to their newest version
alias pacr="sudo /usr/bin/pacman -Rs"           # '[r]emove'            - uninstall one or more packages
alias pacs="/usr/bin/pacman -Ss"                # '[s]earch'            - search for a package using one or more keywords
alias paci="/usr/bin/pacman -Si"                # '[i]nfo'              - show information about a package
alias paclo="/usr/bin/pacman -Qdt"              # '[l]ist [o]rphans'    - list all packages which are orphaned
alias pacc="sudo /usr/bin/pacman -Scc"          # '[c]lean cache'       - delete all not currently installed package files
alias paclf="/usr/bin/pacman -Ql"               # '[l]ist [f]iles'      - list all files installed by a given package
alias pacexpl="/usr/bin/pacman -D --asexp"      # 'mark as [expl]icit'  - mark one or more packages as explicitly installed
alias pacimpl="/usr/bin/pacman -D --asdep"      # 'mark as [impl]icit'  - mark one or more packages as non explicitly installed
# It's Like Never Having to say your sorry
alias pacman='sudo pacman'

# '[r]emove [o]rphans' - recursively remove ALL orphaned packages
alias pacro="/usr/bin/pacman -Qtdq > /dev/null && sudo /usr/bin/pacman -Rs \$(/usr/bin/pacman -Qtdq | sed -e ':a;N;$!ba;s/\n/ /g')"
alias install="sudo apt-get install"
#=============================================================}}}
#=============Language aliases================================{{{
alias rb='ruby'
alias py='python'
alias py2='Python2'
alias ipy='ipython'
alias jj="java jar-"
alias cg="cargo"
#using offical Java installed in /opt
#alias java="/opt/jre-10.0.2/bin/java"

#=============================================================}}}
#=============Configurations=================================={{{
#------------------------------------------------------
cfg-aliasrc() { $EDITOR ~/.aliasrc ;}
cfg-abookrc() { $EDITOR ~/.abook/abookrc ;}
cfg-addressbook() { $EDITOR ~/.abook/addressbook ;}
cfg-autostartrc() { $EDITOR ~/.autostartrc ;}
cfg-bashrc() { $EDITOR ~/.bashrc ;}
cfg-blocklist() { $EDITOR ~/.scripts/blocklist.sh ;}
cfg-cava() { $EDITOR ~/.config/cava/config ;}
cfg-clonezilla() { sudo $EDITOR /etc/drbl/drbl.conf ;}
# https://wiki.archlinux.org/index.php/Cursor_Themes#Choosing_and_Configuring_Cursor_Themes
cfg-cursor() { $EDITOR ~/.icons/default/index.theme ;}
cfg-cursor-list() { ls ~/.icons ;}
cfg-emacs() { $EDITOR ~/.emacs ;}
cfg-emulationstation() { $EDITOR ~/.emulationstation/es_systems.cfg ;}
cfg-emulationstation-input() { $EDITOR ~/.emulationstation/es_input.cfg ;}
cfg-flexget() { $EDITOR ~/.flexget/config.yml ;}
cfg-fstab() { sudo $EDITOR /etc/fstab ;}
cfg-gitignore() { $EDITOR ~/Public/dotfiles/.gitignore ;}
cfg-greenclip() { killall greenclip ; $EDITOR ~/.config/greenclip.cfg && nohup greenclip daemon > /dev/null 2>&1 & }
cfg-group() { sudo $EDITOR /etc/group ;}
cfg-grub() { sudo $EDITOR /etc/default/grub ;}
cfg-hintrc() { $EDITOR ~/.hintrc ;}
cfg-hosts() { sudo $EDITOR /etc/hosts ;}
cfg-hyperterminal() { $EDITOR ~/.hyper.js ;}
cfg-i3wm() { $EDITOR ~/.i3/config ;}
cfg-inputrc() { $EDITOR ~/.inputrc ;}
cfg-internetarchive() { $EDITOR ~/.config/ia.ini ;} # archive.org downloader https://internetarchive.readthedocs.io/en/latest/
cfg-keynavrc() { $EDITOR ~/.keynavrc ;}
cfg-kodi-keyboard() { $EDITOR ~/.kodi/userdata/keymaps/keyboard.xml ;}
cfg-kodi-confluencethumbnailview() { sudo $EDITOR /usr/share/kodi/addons/skin.confluence/720p/MyVideoNav.xml ;}
cfg-lgogdownloader() { $EDITOR ~/.config/lgogdownloader/config.cfg ;}
cfg-livestreamer() { $EDITOR ~/.livestreamerrc ;}
cfg-mailcap() { $EDITOR ~/.mailcap ;}
cfg-mbsyncrc() { $EDITOR ~/.mbsyncrc ;}
cfg-mc() { $EDITOR ~/.config/mc/ini ;}
cfg-mc-keymap() { $EDITOR ~/.config/mc/mc.keymap ;}
cfg-mcomix() { $EDITOR ~/.config/mcomix/keybindings.conf ;}
cfg-megarc() { $EDITOR ~/.megarc ;}
cfg-mpd() { $EDITOR ~/.mpd/mpd.conf ;}
cfg-mplayer() { $EDITOR ~/.mplayer/config ;}
cfg-mpv() { $EDITOR ~/.config/mpv/mpv.conf ;}
cfg-mpv-input() { $EDITOR ~/.config/mpv/input.conf ;}
cfg-mocp() { $EDITOR ~/.moc/config ;}
cfg-muttrc() { $EDITOR ~/.muttrc ;}
cfg-nanorc() { $EDITOR ~/.nanorc;}
cfg-nap() { $EDITOR ~/.nap/napconf ;}
cfg-ncmpcpp() { $EDITOR ~/.ncmpcpp/config ;}
cfg-ncmpcpp-bindings() { $EDITOR ~/.ncmpcpp/bindings ;}
cfg-netrc() { $EDITOR ~/.netrc;}
cfg-newsbeuter() { $EDITOR ~/.newsbeuter/config ;}
cfg-newsbeuter-queue() { $EDITOR ~/.newsbeuter/queue ;}
cfg-newsbeuter-urls() { $EDITOR ~/.newsbeuter/urls ;}
cfg-newsboat() { $EDITOR ~/.newsboat/config ;}
cfg-newsboat-queue() { $EDITOR ~/.newsboat/queue ;}
cfg-newsboat-urls() { $EDITOR ~/.newsboat/urls ;}
cfg-nvim() { $EDITOR ~/.config/nvim/init.vim ;}
cfg-pastebinit() { $EDITOR ~/.pastebinit.xml ;}
cfg-pianobar() { $EDITOR ~/.config/pianobar/config ;}
cfg-pianobar-libao() { sudo $EDITOR /etc/libao.conf ;}
cfg-profile() { $EDITOR ~/.profile ;}
cfg-pulseaudio() { sudo $EDITOR /etc/pulse/default.pa ;}
cfg-pyload() { $EDITOR ~/.pyload/pyload.conf ;}
cfg-pyradio() { $EDITOR ~/.pyradio/stations.csv ;}
cfg-qutebrowser() { $EDITOR ~/.config/qutebrowser/qutebrowser.conf ;}
cfg-qutebrowser-keys() { $EDITOR ~/.config/qutebrowser/keys.conf ;}
cfg-qutebrowser-quickmarks() { $EDITOR ~/.config/qutebrowser/quickmarks ;}
cfg-quicktile() { $EDITOR ~/.config/quicktile.cfg ;}
cfg-rofibangs() { $EDITOR ~/.scripts/rofi-scripts-collection/rofi-bangs.sh ;}
cfg-ranger() { $EDITOR ~/.config/ranger/rc.conf ;}
cfg-ranger-rifle() { $EDITOR ~/.config/ranger/rifle.conf ;}
cfg-ranger-commands() { $EDITOR ~/.config/ranger/commands.py ;}
cfg-retroarch() { $EDITOR ~/.config/retroarch/retroarch.cfg ;}
cfg-rtv() { $EDITOR ~/.config/rtv/rtv.cfg ;}
cfg-samba() { sudo $EDITOR /etc/samba/smb.conf ;}
cfg-skippyxd() { $EDITOR ~/.skippy-xd.rc ;}
cfg-slrnrc() { $EDITOR ~/.slrnrc ;}
cfg-ssh-client() { sudo $EDITOR /etc/ssh/ssh_config ;}
cfg-ssh-daemon() { sudo $EDITOR /etc/ssh/sshd_config ;}
cfg-sudoers() { sudo $EDITOR /etc/sudoers ;}
cfg-bookmarks() { $EDITOR ~/.config/surfraw/bookmarks ;}
cfg-sakura() { $EDITOR ~/.config/sakura/sakura.conf ;}
cfg-surfraw() { $EDITOR ~/.config/surfraw/conf ;}
cfg-syncthing() { $EDITOR ~/.config/syncthing/config.xml ;}
cfg-tmuxrc() { $EDITOR ~/.tmux.conf ;}
cfg-tor() { sudo $EDITOR /etc/tor/torrc ;}
cfg-tor-user() { $EDITOR ~/.torrc ;}
cfg-torrentflix() { torrentflix --config=$EDITOR ;}
cfg-torrench() { $EDITOR ~/.config/torrench/config.ini ;}
cfg-tpb() { $EDITOR ~/.scripts/tpb.sh ;}
cfg-transmission-daemon() { $EDITOR ~/.config/transmission-daemon/settings.json ;}
cfg-transmission-ncurse() { $EDITOR ~/.config/transmission-remote-cli/settings.cfg ;}
cfg-trz() { $EDITOR ~/.scripts/trz.sh ;}
cfg-turses() { $EDITOR ~/.turses/config ;}
cfg-urlview() { $EDITOR ~/.urlview ;}
cfg-updatedb() { sudo $EDITOR /etc/updatedb.conf ;}
cfg-vifmrc() { $EDITOR ~/.config/vifm/vifmrc ;}
cfg-vimrc() { $EDITOR ~/.vimrc ;}
cfg-w3m() { $EDITOR ~/.w3m/config ;}
cfg-w3m-keymap() { $EDITOR ~/.w3m/keymap ;}
cfg-w3m-urimethodmap() { $EDITOR ~/.w3m/urimethodmap ;}
cfg-wegorc() { $EDITOR ~/.wegorc ;}
cfg-xbindkeysrc() { $EDITOR ~/.xbindkeysrc && killall xbindkeys ; xbindkeys ;}
cfg-xboxdrv() { sudo $EDITOR /etc/default/xboxdrv ;}
cfg-xmodmap() { $EDITOR ~/.Xmodmap ;}
cfg-xresources() { $EDITOR ~/.Xresources ;}
cfg-yaourtrc() { $EDITOR ~/.yaourtrc ;}
cfg-zshrc() { $EDITOR ~/.zshrc ;}
cfg-zurlrc() { $EDITOR ~/.zurlrc ;}
#====================================================================}}}
#=============Configurations Reload==========================={{{
#------------------------------------------------------
rld-bashrc() { source ~/.bashrc ;}
rld-font() { fc-cache -v -f ;}
rld-grub() { sudo grub-mkconfig -o /boot/grub/grub.cfg ;}
rld-greenclip() { killall greenclip ; nohup greenclip daemon > /dev/null 2>&1 & }
rld-keynav() { killall keynav ; keynav daemonize ;}
rld-updatedb() { sudo updatedb ;}
rld-xbindkeys() { killall xbindkeys ; xbindkeys ;}
rld-hyperkey() { xmodmap ~/.Xmodmap; killall xcape ; xcape -e 'Hyper_L=Return' ; killall xbindkeys ; xbindkeys ;}
rld-xcape() { killall xcape ; xcape -e 'Hyper_L=Return' ;}
rld-xdefaults() { xrdb ~/.Xdefaults ;}
rld-xmodmap() { xmodmap ~/.Xmodmap ;}
rld-xmodmap-uskeyboardlayout() { setxkbmap -layout us ;} # reset back to US keyboard http://unix.stackexchange.com/a/151046
rld-xresources() { xrdb -load ~/.Xresources ;}
rld-zshrc() { source ~/.zshrc ;}
#==============================================================}}}
#=============Grub ==========================================={{{

update-grub() { sudo grub-mkconfig -o /boot/grub/grub.cfg ;}
grub-update() { sudo grub-mkconfig -o /boot/grub/grub.cfg ;}
grub-list() {
  RED='\033[0;31m'
  sudo grep "menuentry '" /boot/grub/grub.cfg | less -N
  echo -e "${RED} REMINDER: GRUB number starts at zero not one"
}
#==============================================================}}}
#=============Zsh Suffix Alias================================{{{
#
#open file with default program base on extension
#Example: 'alias -s avi=mplayer' makes 'file.avi' execute 'mplayer file.avi'
alias -s {avi,flv,mkv,mp4,mpeg,mpg,ogv,wmv}=$PLAYER
alias -s {flac,mp3,ogg,wav}=$PLAYER
alias -s {gif,GIF,jpeg,JPEG,jpg,JPG,png,PNG}=$IMAGEVIEWER
alias -s {djvu,pdf,ps}=$PDFVIEW
alias -s txt=$EDITOR
alias -s {md,markdown}=$EDITOR
alias -s epub=$EBOOKER
alias -s {cbr,cbz}=$COMICER
alias -s {exe,com,bat}=$DOSSER
# might conflict with emacs org mode
alias -s {at,ch,com,de,net,org}=$BROWSER
alias -s {html,htm}=$BROWSERCLI
# archive extractor
alias -s ace="atool l"
alias -s rar="unrar l"
alias -s {tar,bz2,gz,xz}="tar tvf"	#tar.bz2,tar.gz,tar.xz
alias -s zip="unzip -l"
alias -s sc=scim
#=============================================================}}}
#=============cd .. Aliases==================================={{{
alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'
alias .....='cd ../../../..'
alias ......='cd ../../../../..'
alias .......='cd ../../../../../..'
alias ........='cd ../../../../../../..'
#Moving Around The Stack
alias -- -='cd -'
alias 1='cd -'
alias 2='cd -2'
alias 3='cd -3'
alias 4='cd -4'
alias 5='cd -5'
alias 6='cd -6'
alias 7='cd -7'
alias 8='cd -8'
alias 9='cd -9'
#=============================================================}}}
#=============Rip Disc to Files==============================={{{
#rip Audio cd to flac
alias ripCD='abcde -d /dev/sr0  -o flac'
#Rip Dvd to m4v Format
function ripDVD() { HandBrakeCLI -s "1,2,3,4,5,6,7,8,9" -a "1,2,3,4,5,6,7,8,9"  -i /dev/sr0 -o ~/Videos/${1}.m4v ;}
#RipISO
function ripISO() {cdrecord dev=/dev/sr0 "$1"}

#=============================================================}}}
#=============Global Aliases=================================={{{
#

    # Automatically Expanding Global Aliases (Space key to expand)
    # references: http://blog.patshead.com/2012/11/automatically-expaning-zsh-global-aliases---simplified.html
    globalias() {
      if [[ $LBUFFER =~ '[A-Z0-9]+$' ]]; then
        zle _expand_alias
        zle expand-word
      fi
      zle self-insert
    }
    zle -N globalias
    bindkey " " globalias                 # space key to expand globalalias
    # bindkey "^ " magic-space            # control-space to bypass completion
    bindkey "^[[Z" magic-space            # shift-tab to bypass completion
    bindkey -M isearch " " magic-space    # normal space during searches

    alias -g ls='exa --group-directories-first'
    # http://www.zzapper.co.uk/zshtips.html
    alias -g ND='*(/om[1])' 	      # newest directory
    alias -g NF='*(.om[1])' 	      # newest file
    #alias -g NE='2>|/dev/null'
    alias -g NO='&>|/dev/null'
    alias -g P='2>&1 | $PAGER'
    alias -g VV='| nvim -R -'
    alias -g L='| less'
    alias -g M='| most'
    alias -g C='| wc -l'
    alias -g H='| head'
    alias -g T='| tail'
    alias -g G='| grep'
    alias -g LL="2>&1 | less"
    alias -g CA="2>&1 | cat -A"
    alias -g NE="2> /dev/null"
    alias -g NUL="> /dev/null 2>&1"

           alias -g CA="2>&1 | cat -A"
           alias -g C='| wc -l'
           alias -g D="DISPLAY=:0.0"
           alias -g DN=/dev/null
           alias -g ED="export DISPLAY=:0.0"
           alias -g EG='|& egrep'
           alias -g EH='|& head'
           alias -g EL='|& less'
           alias -g ELS='|& less -S'
           alias -g ETL='|& tail -20'
           alias -g ET='|& tail'
           alias -g F=' | fmt -'
           alias -g G='| egrep'
           alias -g H='| head'
           alias -g HL='|& head -20'
           alias -g Sk="*~(*.bz2|*.gz|*.tgz|*.zip|*.z)"
           alias -g LL="2>&1 | less"
           alias -g LS='| less -S'
           alias -g MM='| most'
           alias -g M='| more'
           alias -g NE="2> /dev/null"
           alias -g NS='| sort -n'
           alias -g NUL="> /dev/null 2>&1"
           alias -g PIPE='|'
           alias -g R=' > /c/aaa/tee.txt '
           alias -g RNS='| sort -nr'
           alias -g S='| sort'
           alias -g TL='| tail -20'
           alias -g T='| tail'
           alias -g US='| sort -u'
           alias -g VM=/var/log/messages
           alias -g X0G='| xargs -0 egrep'
           alias -g X0='| xargs -0'
           alias -g XG='| xargs egrep'
           alias -g X='| xargs'
#==========================================================}}}
##############################FUNCTIONS#########################################
#=============Cli Spell Checking=============================={{{
#Check a single word or a file Requarse
function check-word() { echo "$1" | aspell -a ;}
function ckw() { echo "$1" | aspell -a ;}
function check-file() { aspell check "$1" ;}
#==========================================================}}}
#=============Mount_Imgz======================================{{{

mount-img() {
  if [ $# -lt 1 ]; then
    echo -e "mount image to access files"
    echo -e "\nUsage: $0 <img_file>"
    echo -e "\nExample: $0 foo.img"
    return 1
  fi

  sudo mkdir -p "/media/$1"
  sudo mount "$PWD/$1" "/media/$1"

  # if mount was sucessful then cd and ls the mountpoint
  if [ $? -eq 0 ]; then
    cd "/media/$1" && ls
  else
    return 1
  fi
}


unmount-img() {
  if [ $# -lt 1 ]
  then
    echo -e "unmount ISO filesystem images (iso,nrg,bin,mdf,img)"
    echo -e "\nUsage:\n$0 <mount_point|disc_image>"
    echo -e "\nExample:\n$0 disc_image.iso"
    echo -e "$0 disc_image.iso disc_image2.bin"
    echo -e "$0 mount_point1 mount_point2"
    echo -e "cd /tmp && $0 mount_point"
    echo -e "cd /tmp && $0 *.iso"
    return 1
  fi

  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    fusermount -u "$arg"
  done
}


#==========================================================}}}
#=============Mount Archive (ISO|ZIP|RAR|TAR)================={{{
#------------------------------------------------------
# http://ubuntuforums.org/showthread.php?t=1207096
mount-archive() {
  if [ $# -lt 1 ]
  then
    echo -e "mount archive files (iso|zip|rar|tar...etc)"
    echo -e "\nUsage:\n$0 <archive>"
    echo -e "\nExample:\n$0 file.zip"
    echo -e "$0 *.zip"
    return 1
  fi

  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    gvfs-mount "archive://$( ( echo -n 'file://' ; readlink -f $arg ; ) | perl -MURI::Escape -lne 'print uri_escape($_)')"
  done

  # if mount was sucessful then cd into gvfs dir and ls the mountpoint
  if [ $? -eq 0 ]; then
    cd "/run/user/$(id -u)/gvfs" && ls
  else
    return 1
  fi
}

unmount-archive() {
  if [ $# -lt 1 ]
  then
    echo -e "unmount archive files (iso|zip|rar|tar)"
    echo -e "\nUsage:\n$0 <mount_point>"
    echo -e "\nExample:\n$0 archive:host=file%253Afoo%bar.zip"
    echo -e "cd /run/user/${UID}/gvfs/ && $0 archive:host=file%253Afoo%bar.zip"
    return 1
  fi

  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    gvfs-mount -u "/run/user/$(id -u)/gvfs/$arg"
  done
}

# }}}
#=============Eject Device===================================={{{
#------------------------------------------------------
# DEMO: https://www.youtube.com/watch?v=jhv-2pNWfr4
# DESC: switch audio stream to different output (HDMI, Headphone, Speakers ...etc)
# REFF: http://askubuntu.com/a/18210
# LINK: http://quvi.sourceforge.net/

function pumount() {
  if [ $# -lt 1 ]
  then
    echo -e "mount using gvfs"
    echo -e "\nUsage:\n$0 <disc_image>"
    echo -e "\nExample:\n$0 disc_image.iso"
    echo -e "$0 disc_image.iso disc_image2.bin disc_image3.mdf"
    echo -e "$0 *.iso"
    return 1
  fi

  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    udisksctl power-off -b /dev/"$arg"
  done
}

# }}}
#=============Smartctl - Check Hard Drive Health=============={{{
#------------------------------------------------------
# S.M.A.R.T. is the abbreviation for "Self Monitoring And Reporting Technology"
# It is a standard interface protocol and set of the disk features that allows disk to check its status and report it to a host system
# references:
# https://www.smartmontools.org/browser/trunk/smartmontools/smartctl.8.in
# https://en.wikipedia.org/wiki/S.M.A.R.T.#ATA_S.M.A.R.T._attributes
# http://www.z-a-recovery.com/manual/smart.aspx
# https://ddumont.wordpress.com/2010/03/15/workaround-for-aborted-smart-test-for-seagate-disk/

smartctl-test() {
  if [ $# -lt 1 ]; then
    echo -e "perform conveyance test to check hard drive health (usually 5mins)"
    echo -e "not all drives has this testing feature"
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo smartctl -t conveyance /dev/"$1"
}

smartctl-extendedtest() {
  if [ $# -lt 1 ]; then
    echo -e "perform long extended test to check hard drive health (usually 1hr+)"
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo smartctl -t long /dev/"$1"
}

smartctl-shorttest() {
  if [ $# -lt 1 ]; then
    echo -e "perform short test to check hard drive health (usually 2mins)"
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo smartctl -t short /dev/"$1"
}

smartctl-showprogress() {
  if [ $# -lt 1 ]; then
    echo -e "show the progress of your smartctl self test"
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo watch -n 10 "smartctl -l selftest /dev/$1 ; smartctl -c /dev/$1 | head -11 | tail -3"
}

smartctl-cancletest() {
  if [ $# -lt 1 ]; then
    echo -e "cancle a self test (short, conveyance, extended)"
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo smartctl -X /dev/"$1"
}

smartctl-enablesmart() {
  if [ $# -lt 1 ]; then
    echo -e "enable SMART on your hard drive"
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo smartctl -s on /dev/"$1"
}

smartctl-disablesmart() {
  if [ $# -lt 1 ]; then
    echo -e "disable SMART on your hard drive"
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo smartctl -s off /dev/"$1"
}

smartctl-keepalive() {
  if [ $# -lt 1 ]; then
    echo -e "Keep hard drive from going to sleep by creating a file every 60 seconds."
    echo -e 'Some external hard drive like Seagate will auto sleep on idle, thus we will get a "Aborted by host" in our self-test logs'
    echo -e "references: https://ddumont.wordpress.com/2010/03/15/workaround-for-aborted-smart-test-for-seagate-disk/"
    echo -e "\nUsage: $0 <path>"
    echo -e "Example: $0 ."
    echo -e "         cd /mnt/myseagatehdd && $0 ."
    return 1
  fi
  while true ; do echo "foo" >> test.txt; sleep 60; done
}

smartctl-info() {
  if [ $# -lt 1 ]; then
    echo -e 'Show S.M.A.R.T information of a device'
    echo -e "\nUsage: $0 <device>"
    echo -e "Example: $0 sdx"
    return 1
  fi
  sudo smartctl -a /dev/"$1" | grep -i --color='always' -E 'WARNING|Model Family|Device Model|SMART support is|User Capacity|SMART overall-health self-assessment test result|-fail|Short self-test routine|Extended self-test routine|Conveyance self-test routine|SMART Attributes Data Structure|Power_On_Hours|SMART Self-test log structure|ATA Error Count|FAILING_NOW|$'

  echo "${Red}=============References=================${Color_Off}"
  echo "${Yellow}>>>ATTRIBUTE_NAME meaning: https://en.wikipedia.org/wiki/S.M.A.R.T.#ATA_S.M.A.R.T._attributes ${Color_Off}"
  echo "${Blue}>>>aborted by host (HDD sleep on idle): https://ddumont.wordpress.com/2010/03/15/workaround-for-aborted-smart-test-for-seagate-disk/ ${Color_Off}"
  echo "${Green}>>>Manpage: If the Normalized value (VALUE) is less than or equal to the Threshold value (THRESH), then the Attribute is said to have failed. If the Attribute is a pre-failure Attribute, then disk failure is imminent. ${Color_Off}"
  echo "${Green}>>>Please note: the fact that an Attribute is of type 'Pre-fail' does not mean that your disk is about to fail!${Color_Off}"
  echo "${Green}>>>If the Attribute's current Normalized value is less than or equal to the threshold value, then the "WHEN_FAILED" column will display FAILING_NOW.${Color_Off}"
  echo "${Purple}=====HDD Hours=====${Color_Off}"
  echo "1000  hrs = 41 days"
  echo "8760  hrs = 1 year  (365  days)"
  echo "17520 hrs = 2 years (730  days)"
  echo "26280 hrs = 3 years (1095 days)"
  echo "35040 hrs = 4 years (1460 days)"
  echo "43800 hrs = 5 years (1825 days)"
  echo "52560 hrs = 6 years (2190 days)"
}
# }}}
#=============Fasd============================================{{{
#------------------------------------------------------
alias fasd=/usr/bin/fasd
  eval "$(fasd --init auto)"    # get fasd working, initialization code

  # different fasd listing
   alias a='fasd -a'               # any
   alias S='fasd -si'              # show / search / select
   alias d='fasd -d'               # directory
   alias f='fasd -f'               # file
   alias sd='fasd -sid'            # interactive directory selection
   alias sf='fasd -sif'            # interactive file selection
   alias z='fasd_cd -d'            # cd, same functionality as j in autojump
   alias zz='fasd_cd -d -i'        # cd with interactive selection

  # open with external programs
  alias m="f -e $PLAYER"                # open with video player
  alias o="a -e $OPENER"                # open any file
#==========================================================}}}
#=============Format USB Drive================================{{{
formatmatusb-ext() {
  if [ $# -lt 3 ]; then
    echo -e "format and create a partition that fills up the whole device"
    echo -e "\nUsage: $0 <filesystem:ext2|ext3|ext4> <device_label> <device_name>"
    echo -e "Example: $0 ext2 MY_USB sdx"
    echo -e "         $0 ext3 MY_USB sdx"
    echo -e "         $0 ext4 MY_USB sdx"
    return 1
  fi
  FSTYPE="$1"
  DEVICE_LABEL="$2"
  DEVICE_NAME="$3"
  echo "${Yellow}>>>Checking if device is mounted ${Color_Off}"
    MOUNT_STATUS=$(mount | grep /dev/"$DEVICE_NAME" | wc -l)
    if [ "$MOUNT_STATUS" -ne 0 ]
    then
      lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep "$DEVICE_NAME"
      echo "${Red}>>>/dev/$DEVICE_NAME is mounted. You have to unmount the device and all of its partitions then try again ${Color_Off}"
      return 1
    fi
  echo "${Yellow}>>>Please double check the device you are about to FORMAT ${Color_Off}"
    lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep --color -E "$DEVICE_NAME|$"
  echo -n "${Red}>>>WARNING: You are about to FORMAT a device at /dev/$DEVICE_NAME. Do you want to continue? [y/n] ${Color_Off}"
    read REPLY
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
      echo "${Green}>>>You chose to continue ${Color_Off}"
    else
      return 1
    fi
  echo "${Red}>>>Delete any existing partition then create a new single partition ${Color_Off}"
    echo -e "d\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\no\nn\np\n1\n\n\nw" | sudo fdisk /dev/"$DEVICE_NAME"
    # delete partiton x8 using d\n\n
    # d    delete a partition
    #      default, partition
    # o    create a new empty DOS partition table
    # n    add a new partition
    # p    print the partition table
    # 1    partition number 1
    #      default, start immediately after preceding partition
    #      default, extend partition to end of disk
    # w    write table to disk and exit
  echo "${Red}>>>Formatting the device ${Color_Off}"
    echo -e "y\n" | sudo mkfs."$FSTYPE" -L "$DEVICE_LABEL" /dev/"$DEVICE_NAME"1
  echo "${Yellow}>>>Changing permission of the filesystem ${Color_Off}"
    mkdir -p -v /tmp/testmount
    sudo mount /dev/"$DEVICE_NAME"1 /tmp/testmount
    sudo chmod -R 777 /tmp/testmount
  echo "${Green}>>>Change EXT filesystem 5% reserved space to 0% (increase storage space) ${Color_Off}"
    MOUNTED_TESTMOUNT=$(df | awk '/testmount/ {print $1}')
    sudo tune2fs -m 0 "$MOUNTED_TESTMOUNT"
    sudo tune2fs -l "$MOUNTED_TESTMOUNT" | grep --color=auto 'Reserved block count'
  echo "${Red}>>>Unmounting and cleanup ${Color_Off}"
    sudo umount /tmp/testmount
    rmdir -v /tmp/testmount
}

formatusb-gamecube() {
  if [ $# -lt 2 ]; then
    echo -e "format device to work with wii & gamecube games using FAT32 with 32KB cluster"
    echo -e "FAT32 label max is 11 character and is all uppercase"
    echo -e "512 bytes (per sector) * 64 sectors (per cluster) = 32KB clusters (32768 Bytes)"
    echo -e "more info: https://gist.github.com/joshenders/4376942"
    echo -e "\nUsage: $0 <label> <device>"
    echo -e "Example: $0 MY_USB sdx"
    return 1
  fi
  # fat32 likes the labels to be in uppercase
  DEVICE_LABEL=$(echo "$1" | tr '[:lower:]' '[:upper:]')
  DEVICE_NAME="$2"
  echo "${Yellow}>>>Checking if device is mounted ${Color_Off}"
    MOUNT_STATUS=$(mount | grep /dev/"$DEVICE_NAME" | wc -l)
    if [ "$MOUNT_STATUS" -ne 0 ]
    then
      lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep "$DEVICE_NAME"
      echo "${Red}>>>/dev/$DEVICE_NAME is mounted. You have to unmount the device and all of its partitions then try again ${Color_Off}"
      return 1
    fi
  echo "${Yellow}>>>Please double check the device you are about to FORMAT ${Color_Off}"
    lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep --color -E "$2|$"
  echo -n "${Red}>>>WARNING: You are about to FORMAT a device at /dev/$DEVICE_NAME. Do you want to continue? [y/n] ${Color_Off}"
    read REPLY
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
      echo "${Green}>>>You chose to continue ${Color_Off}"
    else
      return 1
    fi
  echo "${Red}>>>Delete any existing partition then create a new single partition ${Color_Off}"
    echo -e "d\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\no\nn\np\n1\n\n\nt\nb\nw" | sudo fdisk /dev/"$DEVICE_NAME"
    # delete partiton x8 using d\n\n
    # d    delete a partition
    #      default, partition
    # o    create a new empty DOS partition table
    # n    add a new partition
    # p    print the partition table
    # 1    partition number 1
    #      default, start immediately after preceding partition
    #      default, extend partition to end of disk
    # t    change a partition type (L to list all types)
    # b    W95 FAT32
    # w    write table to disk and exit
  echo "${Red}>>>Formatting the device ${Color_Off}"
    sudo mkfs.fat -S 512 -s 64 -F 32 -n "$DEVICE_LABEL" -I /dev/"$DEVICE_NAME"1
  echo "${Red}>>>Changing permission of the filesystem ${Color_Off}"
    mkdir -p -v /tmp/testmount
    sudo mount /dev/"$DEVICE_NAME"1 /tmp/testmount
    sudo chmod -R 777 /tmp/testmount
    sudo umount /tmp/testmount
    rmdir -v /tmp/testmount
}

formatusb-exfat() {
  if [ $# -lt 2 ]; then
    echo -e "format and create a partition that fills up the whole device"
    echo -e "exFAT label max is 15 character and is all uppercase"
    echo -e "\nUsage: $0 <label> <device>"
    echo -e "Example: $0 MY_USB sdx"
    return 1
  fi
  # exFat likes the labels to be in uppercase
  DEVICE_LABEL=$(echo "$1" | tr '[:lower:]' '[:upper:]')
  DEVICE_NAME="$2"
  echo "${Yellow}>>>Checking if device is mounted ${Color_Off}"
    MOUNT_STATUS=$(mount | grep /dev/"$DEVICE_NAME" | wc -l)
    if [ "$MOUNT_STATUS" -ne 0 ]
    then
      lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep "$DEVICE_NAME"
      echo "${Red}>>>/dev/$DEVICE_NAME is mounted. You have to unmount the device and all of its partitions then try again ${Color_Off}"
      return 1
    fi
  echo "${Yellow}>>>Please double check the device you are about to FORMAT ${Color_Off}"
    lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep --color -E "$2|$"
  echo -n "${Red}>>>WARNING: You are about to FORMAT a device at /dev/$DEVICE_NAME. Do you want to continue? [y/n] ${Color_Off}"
    read REPLY
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
      echo "${Green}>>>You chose to continue ${Color_Off}"
    else
      return 1
    fi
  echo "${Red}>>>Delete any existing partition then create a new single partition ${Color_Off}"
    echo -e "d\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\no\nn\np\n1\n\n\nt\n7\nw" | sudo fdisk /dev/"$DEVICE_NAME"
    # delete partiton x8 using d\n\n
    # d    delete a partition
    #      default, partition
    # o    create a new empty DOS partition table
    # n    add a new partition
    # p    print the partition table
    # 1    partition number 1
    #      default, start immediately after preceding partition
    #      default, extend partition to end of disk
    # t    change a partition type (L to list all types)
    # 7    HPFS/NTFS/exFAT
    # w    write table to disk and exit
  echo "${Red}>>>Formatting the device ${Color_Off}"
    sudo mkfs.exfat -n "$DEVICE_LABEL" /dev/"$DEVICE_NAME"1
  echo "${Red}>>>Changing permission of the filesystem ${Color_Off}"
    mkdir -p -v /tmp/testmount
    sudo mount /dev/"$DEVICE_NAME"1 /tmp/testmount
    sudo chmod -R 777 /tmp/testmount
    sudo umount /tmp/testmount
    rmdir -v /tmp/testmount
}

formatusb-fat32() {
  if [ $# -lt 2 ]; then
    echo -e "format and create a partition that fills up the whole device"
    echo -e "FAT32 label max is 11 character and is all uppercase"
    echo -e "\nUsage: $0 <label> <device>"
    echo -e "Example: $0 MY_USB sdx"
    return 1
  fi
  # fat32 likes the labels to be in uppercase
  DEVICE_LABEL=$(echo "$1" | tr '[:lower:]' '[:upper:]')
  DEVICE_NAME="$2"
  echo "${Yellow}>>>Checking if device is mounted ${Color_Off}"
    MOUNT_STATUS=$(mount | grep /dev/"$DEVICE_NAME" | wc -l)
    if [ "$MOUNT_STATUS" -ne 0 ]
    then
      lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep "$DEVICE_NAME"
      echo "${Red}>>>/dev/$DEVICE_NAME is mounted. You have to unmount the device and all of its partitions then try again ${Color_Off}"
      return 1
    fi
  echo "${Yellow}>>>Please double check the device you are about to FORMAT ${Color_Off}"
    lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep --color -E "$2|$"
  echo -n "${Red}>>>WARNING: You are about to FORMAT a device at /dev/$DEVICE_NAME. Do you want to continue? [y/n] ${Color_Off}"
    read REPLY
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
      echo "${Green}>>>You chose to continue ${Color_Off}"
    else
      return 1
    fi
  echo "${Red}>>>Delete any existing partition then create a new single partition ${Color_Off}"
    echo -e "d\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\no\nn\np\n1\n\n\nt\nb\nw" | sudo fdisk /dev/"$DEVICE_NAME"
    # delete partiton x8 using d\n\n
    # d    delete a partition
    #      default, partition
    # o    create a new empty DOS partition table
    # n    add a new partition
    # p    print the partition table
    # 1    partition number 1
    #      default, start immediately after preceding partition
    #      default, extend partition to end of disk
    # t    change a partition type (L to list all types)
    # b    W95 FAT32
    # w    write table to disk and exit
  echo "${Red}>>>Formatting the device ${Color_Off}"
    sudo mkfs.fat -F 32 -n "$DEVICE_LABEL" -I /dev/"$DEVICE_NAME"1
  echo "${Red}>>>Changing permission of the filesystem ${Color_Off}"
    mkdir -p -v /tmp/testmount
    sudo mount /dev/"$DEVICE_NAME"1 /tmp/testmount
    sudo chmod -R 777 /tmp/testmount
    sudo umount /tmp/testmount
    rmdir -v /tmp/testmount
}

formatusb-ntfs() {
  if [ $# -lt 2 ]; then
    echo -e "format and create a partition that fills up the whole device"
    echo -e "\nUsage: $0 <label> <device>"
    echo -e "Example: $0 MY_USB sdx"
    return 1
  fi
  DEVICE_LABEL="$1"
  DEVICE_NAME="$2"
  echo "${Yellow}>>>Checking if device is mounted ${Color_Off}"
    MOUNT_STATUS=$(mount | grep /dev/"$DEVICE_NAME" | wc -l)
    if [ "$MOUNT_STATUS" -ne 0 ]
    then
      lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep "$DEVICE_NAME"
      echo "${Red}>>>/dev/$DEVICE_NAME is mounted. You have to unmount the device and all of its partitions then try again ${Color_Off}"
      return 1
    fi
  echo "${Yellow}>>>Please double check the device you are about to FORMAT ${Color_Off}"
    lsblk -o "NAME,SIZE,FSTYPE,TYPE,LABEL,MOUNTPOINT,UUID" | grep --color -E "$DEVICE_NAME|$"
  echo -n "${Red}>>>WARNING: You are about to FORMAT a device at /dev/$DEVICE_NAME. Do you want to continue? [y/n] ${Color_Off}"
    read REPLY
    if [[ $REPLY =~ ^[Yy]$ ]]
    then
      echo "${Green}>>>You chose to continue ${Color_Off}"
    else
      return 1
    fi
  echo "${Red}>>>Delete any existing partition then create a new single partition ${Color_Off}"
    echo -e "d\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\nd\n\no\nn\np\n1\n\n\nt\n7\nw" | sudo fdisk /dev/"$DEVICE_NAME"
    # delete partiton x8 using d\n\n
    # d    delete a partition
    #      default, partition
    # o    create a new empty DOS partition table
    # n    add a new partition
    # p    print the partition table
    # 1    partition number 1
    #      default, start immediately after preceding partition
    #      default, extend partition to end of disk
    # t    change a partition type (L to list all types)
    # 7    HPFS/NTFS/exFAT
    # w    write table to disk and exit
  echo "${Red}>>>Formatting the device ${Color_Off}"
    sudo mkfs.ntfs -f -L "$DEVICE_LABEL" /dev/"$DEVICE_NAME"1
  echo "${Red}>>>Changing permission of the filesystem ${Color_Off}"
    mkdir -p -v /tmp/testmount
    sudo mount /dev/"$DEVICE_NAME"1 /tmp/testmount
    sudo chmod -R 777 /tmp/testmount
    sudo umount /tmp/testmount
    rmdir -v /tmp/testmount
}

#==========================================================}}}
#=============PulseAudio Switcher CLI v2======================{{{
#------------------------------------------------------
# DEMO: https://www.youtube.com/watch?v=jhv-2pNWfr4
# DESC: switch audio stream to different output (HDMI, Headphone, Speakers ...etc)
# REFF: http://askubuntu.com/a/18210

pa-global() {
  if [ $# -lt 1 ]; then
  echo -e "pulseaudio redirect audio of all running app to another device"
  echo -e "\nUsage:\n$0 <device_index_number>"
  echo -e "\nExample:\n$0 0 \n"
  echo "==============="
  echo "Sound Devices"
  pacmd list-sinks | awk '/index/ || /name:/'
  return 1
  fi

  # list all apps in playback tab (ex: cmus, mplayer, vlc)
  inputs=($(pacmd list-sink-inputs | awk '/index/ {print $2}'))
  # set the default output device
  pacmd set-default-sink $1 &> /dev/null
  # apply the changes to all running apps to use the new output device
  for i in ${inputs[*]}; do pacmd move-sink-input $i $1 &> /dev/null; done
}
pa-solo() {
  if [ $# -lt 2 ]; then
  echo -e "pulseaudio redirect audio of one running app to another device"
  echo -e "\nUsage:\n$0 <app_index_number> <device_index_number>"
  echo -e "\nExample:\n$0 2302 0 \n"
  echo "==============="
  echo "Running Apps"
  pacmd list-sink-inputs | awk '/index/ || /application.name /'
  echo "==============="
  echo "Sound Devices"
  pacmd list-sinks | awk '/index/ || /name:/'
  return 1
  fi

  # set the default output device
  pacmd set-default-sink "$2" &> /dev/null
  # apply changes to one running app to use the new output device
  pacmd move-sink-input "$1" "$2" &> /dev/null
}

#=============================================================}}}
#=============Convert to Audio================================{{{
#------------------------------------------------------
# REFF: https://trac.ffmpeg.org/wiki/Encode/MP3
#       https://trac.ffmpeg.org/wiki/Encode/AAC
#       https://trac.ffmpeg.org/wiki/TheoraVorbisEncodingGuide

audio-mp3() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.m4a"
    echo -e "$0 file1.m4a file2.m4a file3.m4a"
    echo -e "$0 *.m4a"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".mp3 ]
    do
      ffmpeg -i "$arg" -codec:a libmp3lame -qscale:a 2 "${arg%.*}".mp3
    done
  done
}
audio-m4a() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp3"
    echo -e "$0 file1.mp3 file2.mp3 file3.mp3"
    echo -e "$0 *.mp3"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".m4a ]
    do
      ffmpeg -i "$arg" -codec:a aac -qscale:a 6 -strict experimental "${arg%.*}".m4a
    done
  done
}

audio-ogg() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp3"
    echo -e "$0 file1.mp3 file2.mp3 file3.mp3"
    echo -e "$0 *.mp3"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".ogg ]
    do
      ffmpeg -i "$arg" -codec:a libvorbis -qscale:a 5 -vn "${arg%.*}".ogg
    done
  done
}

audio-wav() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp3"
    echo -e "$0 file1.mp3 file2.mp3 file3.mp3"
    echo -e "$0 *.mp3"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".wav ]
    do
      ffmpeg -i "$arg" "${arg%.*}".wav
    done
  done
}

audio-webm() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp3"
    echo -e "$0 file1.mp3 file2.mp3 file3.mp3"
    echo -e "$0 *.mp3"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".webm ]
    do
      ffmpeg -i "$arg" -codec:a libvorbis -qscale:a 5 -vn "${arg%.*}".webm
    done
  done
}

convert2audio-wavmono() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp3"
    echo -e "$0 file1.mp3 file2.mp3 file3.mp3"
    echo -e "$0 *.mp3"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}"-monoaudiotrack.wav ]
    do
      ffmpeg -i "$arg" -codec:a pcm_mulaw -ar 8000 -ac 1 "${arg%.*}"-monoaudiotrack.wav
    done
  done
}

convert2audio-wma() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp3"
    echo -e "$0 file1.mp3 file2.mp3 file3.mp3"
    echo -e "$0 *.mp3"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".wma ]
    do
      ffmpeg -i "$arg" -codec:a wmav2 -b:a 128k "${arg%.*}".wma
    done
  done
}

#=============================================================}}}
#=============Convert to Video================================{{{
#------------------------------------------------------
# REFF: http://linuxconfig.org/ffmpeg-audio-format-conversions

convert2video-mp4-h265() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.avi"
    echo -e "$0 file1.avi file2.avi file3.avi"
    echo -e "$0 *.avi"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".mp4 ]
    do
      # ffmpeg -i "$arg" -codec:v libx264 -preset medium -crf 22 -codec:a aac -qscale:a 6 -strict experimental "${arg%.*}".mp4
      # ffmpeg -i "$arg" -codec:v libx265 -preset medium -crf 28 -codec:a aac -qscale:a 6 -strict experimental "${arg%.*}".mp4
      ffmpeg -i "$arg" -codec:v libx265 -preset medium -crf 28 -codec:a aac -qscale:a 6 "${arg%.*}".mp4
      # ffmpeg -i input -c:v libx265 -preset medium -crf 28 -c:a aac -b:a 128k output.mp4
    done
  done
}

convert2video-mp4() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.avi"
    echo -e "$0 file1.avi file2.avi file3.avi"
    echo -e "$0 *.avi"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".mp4 ]
    do
      ffmpeg -i "$arg" -codec:v libx264 -preset medium -crf 22 -codec:a aac -qscale:a 6 -strict experimental "${arg%.*}".mp4
    done
  done
}

convert2video-avi() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp4"
    echo -e "$0 file1.mp4 file2.mp4 file3.mp4"
    echo -e "$0 *.mp4"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".avi ]
    do
      ffmpeg -i "$arg" -codec:v mpeg4 -vtag xvid -qscale:v 3 -codec:a libmp3lame -qscale:a 4 "${arg%.*}".avi
    done
  done
}
convert2video-ogv() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp4"
    echo -e "$0 file1.mp4 file2.mp4 file3.mp4"
    echo -e "$0 *.mp4"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".ogv ]
    do
      ffmpeg -i "$arg" -codec:v libtheora -qscale:v 7 -codec:a libvorbis -qscale:a 5 "${arg%.*}".ogv
    done
  done
}
convert2video-mpg() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp4"
    echo -e "$0 file1.mp4 file2.mp4 file3.mp4"
    echo -e "$0 *.mp4"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".mpg ]
    do
      ffmpeg -i "$arg" -codec:v mpeg2video -qscale:v 2 -codec:a mp2 -b:a 192k "${arg%.*}".mpg
    done
  done
}
convert2video-mkv() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp4"
    echo -e "$0 file1.mp4 file2.mp4 file3.mp4"
    echo -e "$0 *.mp4"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".mkv ]
    do
      ffmpeg -i "$arg" -codec:v libx264 -preset medium -crf 22 -codec:a libvorbis -qscale:a 5 "${arg%.*}".mkv
    done
  done
}
convert2video-webm() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file.mp4"
    echo -e "$0 file1.mp4 file2.mp4 file3.mp4"
    echo -e "$0 *.mp4"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}".webm ]
    do
      ffmpeg -i "$arg" -codec:v libvpx -crf 10 -b:v 1M -codec:a libvorbis "${arg%.*}".webm
    done
  done
}

convert_to_gifv() {
    if [ $# -lt 1 ]
    then
        echo -e "convert video to animated gif"
        echo -e "\nUsage:\n$0 <file> <resolution>"
        echo -e "\nexample:\n$0 file.mkv \n"
        echo -e "$0 file.mkv 320\n"
        echo -e "$0 file.mkv 720\n"
        echo -e "$0 file.mkv 1080\n"
        echo -e "Note: animated gif size are usually x2 or x3 the size of the original video file"

        return 1
    fi

    # get video resolution (height)
    eval $(ffprobe -v error -of flat=s=_ -select_streams v:0 -show_entries stream=height,width "$1")
    size=${streams_stream_0_height}

    ffmpeg -i "$1" -vf scale="${2:-$size}":-1 -r 10 -f image2pipe -vcodec ppm - | convert -delay 5 -loop 0 - "${1%.*}"-gifvid"$2".gif
}
###### DVD to ISO
function dvd2iso()
{
# to get desired device
df -h -x tmpfs -x usbfs
echo -n "Using the information in the terminal window, please enter the appropriate DVD drive:
"
read DVDDEVICE
echo -n "Please enter a name for the ISO file you will create:
"
read XVIDNAME
pv "$DVDDEVICE" | dd of="$XVIDNAME".iso
}

###### DVD to VOB
# requires vobcopy: sudo apt-get install vobcopy
# alias dvd2vob='vobcopy -i /dev/dvd -o ~/ -l'


function geniso() {
	# copyright 2007 - 2010 Christopher Bratusek
	if [[ $CD_WRITER ]]; then
		dd $DD_OPTS if=$CD_WRITER of="$1"
	else	dd $DD_OPTS if=/dev/dvdrw of="$1"
	fi
}
# }}}
#=============Archive Manager CLI============================={{{
#------------------------------------------------------
archive-append() { atool -a "$@" ;}
archive-extract() { atool -x "$@" ;}
archive-list() { atool -l "$1" | less -N ;}
archive-search() { atool -l "$1" | grep -i "$2" ;}

# create archive
archive-create-7z() { atool -a archive.7z "$@" ;}
archive-create-zip() { atool -a archive.zip "$@" ;}
archive-create-rar() { atool -a archive.rar "$@" ;}
archive-create-tar() { atool -a archive.tar "$@" ;}
archive-create-targz() { atool -a archive.tar.gz "$@" ;}
archive-create-cbz() { atool -a archive.zip "$@" && mv -- archive.zip archive.cbz ;}
archive-create-cbr() { atool -a archive.rar "$@" && mv -- archive.rar archive.cbr ;}

# converting archive
convert2archive-tar() { arepack -F .tar -e "$@" ;}
convert2archive-zip() { arepack -F .zip -e "$@" ;}
convert2archive-rar() { arepack -F .rar -e "$@" ;}
convert2archive-targz() { arepack -F .tar.gz -e "$@" ;}
convert2archive-7z() { arepack -F .7z -e "$@" ;}
convert2archive-cbz() {
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    if [[ ! -f "${arg%%.*}".zip && ! -f "${arg%%.*}".cbz ]]; then
      arepack -F .zip -e "$arg" && mv -- "${arg%%.*}".zip "${arg%%.*}".cbz
    else
      if [[ -f "${arg%%.*}".zip && ! -f "${arg%%.*}".cbz ]]; then
        mv -v -- "${arg%%.*}".zip "${arg%%.*}".cbz
      fi
    fi
  done
}
convert2archive-cbr() {
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    if [[ ! -f "${arg%%.*}".rar && ! -f "${arg%%.*}".cbr ]]; then
      arepack -F .rar -e "$arg" && mv -- "${arg%%.*}".rar "${arg%%.*}".cbr
    else
      if [[ -f "${arg%%.*}".rar && ! -f "${arg%%.*}".cbr ]]; then
        mv -v -- "${arg%%.*}".rar "${arg%%.*}".cbr
      fi
    fi
  done
}

#==============================================================}}}
#=============Image Resizer==================================={{{
#------------------------------------------------------
# Resizing Pictures to different resolutions

image-resize-32x32() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 32x32 "${arg%.*}"_32x32_resized."${arg##*.}"
  done
}

image-resize-96x96() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 96x96 "${arg%.*}"_96x96_resized."${arg##*.}"
  done
}

image-resize-128x128() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 128x128 "${arg%.*}"_128x128_resized."${arg##*.}"
  done
}

image-resize-640x480() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 640x480 "${arg%.*}"_640x480_resized."${arg##*.}"
  done
}

image-resize-800x600() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 800x600 "${arg%.*}"_800x600_resized."${arg##*.}"
  done
}

image-resize-1024x768() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 1024x768 "${arg%.*}"_1024x768_resized."${arg##*.}"
  done
}

image-resize-1280x720() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 1280x720 "${arg%.*}"_1280x720_resized."${arg##*.}"
  done
}

image-resize-1280x960() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 1280x960 "${arg%.*}"_1280x960_resized."${arg##*.}"
  done
}

image-resize-1920x1080() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 1920x1080 "${arg%.*}"_1920x1080_resized."${arg##*.}"
  done
}


image-resize-460x215() {
  if [ $# -lt 1 ]
  then
    echo -e "resize pictures to another resolution"
    echo -e "\nUsage:\n$0 <picture>"
    echo -e "\nExample:\n$0 pic1.png pic2.png pic3.png"
    echo -e "$0 *.jpg"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    convert "$arg" -resize 460x215 "${arg%.*}"_1920x1080_resized."${arg##*.}"
  done
}
#===============================================================}}}
#=============Internet Stuff=================================={{{
# search commandlinefu.com
cmdfu() { curl "http://www.commandlinefu.com/commands/matching/$(echo "$@" \
	| sed 's/ /-/g')/$(echo -n $@ | base64)/plaintext" ;}

# display one random command from commandlinefu.com
cmdfu-random() { echo -e "`curl -sL http://www.commandlinefu.com/commands/random/json|sed -re 's/.*,"command":"(.*)","summary":"([^"]+).*/\\x1b[1;32m\2\\n\\n\\x1b[1;33m\1\\x1b[0m/g'`\n" ;}

function 4chanimages()
{
curl -s http://boards.4chan.org/wg/|sed -r 's/.*href="([^"]*).*/\1\n/g'|grep images|xargs wget
}

#===============================================================}}}
#=============Youtube-dl======================================{{{
#------------------------------------------------------
# DEMO: https://www.youtube.com/watch?v=MFxlwVhwayg
# DESC: download/stream media from many online sites
youtube-dl-stream() { youtube-dl -o - "$1" | $PLAYER - ;}

# DESC: convert youtube to audio (youtube.com only)
# -f 171 = webm audio (vorbis)
# -f 140 = m4a (aac)
yt2ogg() { youtube-dl -c --restrict-filenames -x --audio-format vorbis -o "%(title)s.%(ext)s" -f 171 "$@" ;}
yt2wav() { youtube-dl -c --restrict-filenames -x --audio-format wav -o "%(title)s.%(ext)s" -f 171 "$@" ;}
yt2mp3() { youtube-dl -c --restrict-filenames -x --audio-format mp3 -o "%(title)s.%(ext)s" -f 171 "$@" ;}
yt2webmaudio() { youtube-dl -c --restrict-filenames -o "%(title)s.%(ext)s" -f 171 "$@" ;}
yt2m4a() { youtube-dl -c --restrict-filenames -o "%(title)s.%(ext)s" -f 140 "$@" ;}

#=============================================================}}}
#=============RipMe CLI======================================={{{
#------------------------------------------------------
# DEMO: https://www.youtube.com/watch?v=gX9-tYGB-mY
# DESC: image album downloader for wallpaper, comic, hentai, manga
# LINK: https://github.com/4pr0n/ripme
# REFF: https://github.com/4pr0n/ripme/wiki/How-To-Run-RipMe
# REFF: https://github.com/4pr0n/ripme/issues/8 (Supported Sites)


PATH_RIPME=~/.bin/ripme/ripme.jar
ripme-help() { java -jar $PATH_RIPME -h ;}
ripme-supported() { w3m -dump https://github.com/4pr0n/ripme/issues/8 | less ;}
ripme-cli() { java -jar $PATH_RIPME -l ~/Downloads -u "$@" ;}
ripme-cbz() {
  java -jar $PATH_RIPME -l ~/Downloads -u "$@"
  zip -r "${$(ls -1dt ~/Downloads/*/ | head -1)%/}.cbz" "$(ls -1dt ~/Downloads/*/ | head -1)"
  gvfs-trash -f "$(ls -1dt ~/Downloads/*/ | head -1)"
}
ripme-tsp() {
  tsp java -jar $PATH_RIPME -l ~/Downloads -u "$@"
  sleep 2
  tsp zip -r "${$(ls -1dt ~/Downloads/*/ | head -1)%/}.cbz" "$(ls -1dt ~/Downloads/*/ | head -1)"
  tsp gvfs-trash -f "$(ls -1dt ~/Downloads/*/ | head -1)"
}

#=============================================================}}}
#=============Quvi (Download/Stream Media CLI)================{{{
#------------------------------------------------------
# DEMO: https://www.youtube.com/watch?v=jLw64k8CoMc
# LINK: http://quvi.sourceforge.net/
# DESC: media downloader and streamer using external player

quvi-dl() { quvi get "$1" ;}
quvi-stream() { quvi dump "$1" -b quiet --exec "$PLAYER %u" ;}

# }}}
#=============System Information=============================={{{
#------------------------------------------------------
soundc() { arecord -L && arecord -l && cat /proc/asound/pcm ;} #List audio capture card/mic
m-distro() { uname -a && lsb_release -a ;}
connections() {
  echo "--------------- Connected Devices -----------------"
    nmap -sn $(netstat -rn | awk 'FNR == 3 {print $2}')/24
  echo "---------------------------------------------------"
}

# uses ip or ifconfig, good on older or newer system
myip() {
  echo "--------------- Network Information ---------------"
  echo "router ip:" $(netstat -rn | awk 'FNR == 3 {print $2}')
  # newer system like archlinux
  ip addr | awk '/global/ {print $1,$2}' | cut -d\/ -f1
  ip addr | awk '/global/ {print $3,$4}'
  ip addr | awk '/ether/ {print $1,$2}'
  ip addr | awk '/scope link/ {print $1,$2}' | cut -d\/ -f1
  # older system like debian
  ifconfig | awk '/inet addr/ {print $1,$2}' | awk -F: '{print $1,$2}'
  ifconfig | awk '/Bcast/ {print $3}' | awk -F: '{print $1,$2}'
  ifconfig | awk '/inet addr/ {print $4}' | awk -F: '{print $1,$2}'
  ifconfig | awk '/HWaddr/ {print $4,$5}'
  ifconfig | awk '/Scope:Link/ {print $1,$3}' | cut -d\/ -f1
  # echo External IP $(curl -s http://checkip.dyndns.org/ | grep -o "[[:digit:].]\+")
  # echo External IP: $(curl -s http://ipaddr.io/)
  # echo External IP: $(curl -s https://icanhazip.com/)
  # echo External IP: $(curl -s https://ifconfig.co/)
  # echo External IP: $(curl -s http://pasteip.me/api/cli/ && echo)
  echo external ip: $(curl -s http://ipecho.net/plain)
  echo "---------------------------------------------------"
}
#}}}
#=============Search for Files================================{{{
#------------------------------------------------------

@find() {
  if [ $# -lt 1 ]
    then
    echo -e "find files recursively starting from current folder"
    echo -e "\nUsage:     $0 <keywords>"
    echo -e "Example:     $0 dragon ball z"
    echo -e "OR Operator: $0 '(naruto|bleach)'"
    echo -e "             $0 '(naruto|bleach) (mkv|mp4)'"
    echo -e "Extension:   $0 naruto mkv$"
    echo -e "             $0 '(naruto|bleach) (mkv|mp4)$'"
    echo -e "\nQuit vim:\nShift+ZZ or Shift+ZQ"
    return 1
  fi
    keyword=$(echo "$@" |  sed -e 's/ /.*/g' -e 's:|:\\|:g' -e 's:(:\\(:g' -e 's:):\\):g')
    find . -print | grep -i "$keyword" | vim -R -
}

@locate() {
  if [ $# -lt 1 ]
  then
    echo -e "search for files using updatedb"
    echo -e "\nUsage:     $0 <keywords>"
    echo -e "Example:     $0 dragon ball z"
    echo -e "OR Operator: $0 '(naruto|bleach)'"
    echo -e "             $0 '(naruto|bleach) (mkv|mp4)'"
    echo -e "Extension:   $0 naruto mkv$"
    echo -e "             $0 '(naruto|bleach) (mkv|mp4)$'"
    echo -e "\nUpdate Database: sudo updatedb"
    echo -e "\nQuit vim:\nShift+ZZ or Shift+ZQ"
    return 1
  fi
    # escape spaces, pipe and parentheses
    keyword=$(echo "$@" |  sed -e 's/ /.*/g' -e 's:|:\\|:g' -e 's:(:\\(:g' -e 's:):\\):g')
    locate -ir "$keyword" | vim -R -
}

# http://askubuntu.com/questions/460535/how-do-i-tell-locate-to-keep-the-index-of-an-external-hdd
updatedb-external() {
    if [ $# -lt 1 ]
    then
        echo -e "create private updatedb"
        echo -e "\nUsage:\n$0 <filename.db> <path>"
        echo -e "\nexample:\n$0 bingbong /media/bingbong"
        return 1
    fi
    mkdir -p ~/.updatedb
    updatedb -l 0 -o ~/.updatedb/"$1.db" -U "$2"
}

@discover() {
  if [ $# -lt 1 ]
  then
    echo -e "locate using private updatedb"
    echo -e "\nUsage:\n$0 <keywords>"
    echo -e "\nexample:\n$0 dragon ball z"
    echo -e "\nending extension:\n$0 naruto mkv$"
    echo -e "\nOR operator:\n$0 '(naruto|blech)'"
    echo -e "$0 '(naruto|bleach) (mkv|mp4)'"
    echo -e "\nupdate database:\nsudo updatedb"
    echo -e "\nquit vim:\nShift+ZZ or Shift+ZQ"
    return 1
  fi
    keyword=$(echo "$@" |  sed -e 's/ /.*/g' -e 's:|:\\|:g' -e 's:(:\\(:g' -e 's:):\\):g')
    locate \
    -d /var/lib/mlocate/mlocate.db \
    -d ~/.updatedb/Datafiles.db.db \

    -d ~/.updatedb/bingbong.db \
    -d ~/.updatedb/dreamcast_megacd_segacd.db \
    -d ~/.updatedb/gamecube.db \
    -d ~/.updatedb/kamui.db \
    -d ~/.updatedb/nintendo_ds_amiga.db \
    -d ~/.updatedb/og_xbox.db \
    -d ~/.updatedb/ps1ps2saturn.db \
    -d ~/.updatedb/ps2iso.db \
    -d ~/.updatedb/psp_psn_dlc.db \
    -d ~/.updatedb/wasp.db \
    -d ~/.updatedb/wiiiso.db \
    -d ~/.updatedb/wiiredump.db \
    -ir "$keyword" | vim -R -
}
@discover-tmux() { @discover "$@" && tmux kill-pane ;}

whileloop() { while true; do "$@"; sleep 1; done ;}

# find starting at current dir and go recursively to sub dir
# @search() {
#     if [ $# -lt 1 ]
#     then
#         echo -e "search for files "
#         echo -e "\nUsage:\n$0 <keywords>"
#         echo -e "\nexample:\n$0 dragon ball z"
#         echo -e "\nending extension:\n$0 naruto mkv$"
#         echo -e "\nOR operator:\n$0 '(naruto|blech)'"
#         echo -e "$0 '(naruto|bleach) (mkv|mp4)'"
#         echo -e "\nupdate database:\nsudo updatedb"
#         echo -e "\nquit vim:\nShift+ZZ or Shift+ZQ"
#         return 1
#     fi
#         keyword=$(echo "*$@*" |  sed -e 's/ /*/g')
# 	find -type f -iname $keyword | vim -R -
# }

# find current dir files bigger than X size
# useage: @size <filesize> <keyword>
@size() {
	keyword=$(echo "*${@:2}*" |  sed -e 's/ /*/g')
	find -type f -size +${1}M -iname $keyword  | vim -R - ;}

# search pdf files in current dir for keywords inside the pdfs
# http://www.commandlinefu.com/commands/view/9189
@pdfgrep() {
    if [ $# -lt 1 ]
    then
        echo -e "search all pdf in current directory recursively for keyword inside the pdfs"
        echo -e "\nUsage:\n$0 <keyword>"
        echo -e "\nexample:\n$0 homework"
        echo -e "\n$0 'school transcript'"

        return 1
    fi
	find -iname \*.pdf -print0 | xargs -0 pdfgrep -in "$@"
}


@surfraw() { cat ~/.config/surfraw/bookmarks | grep -i "$1" | vim -R - ;}

#=============================================================}}}
#=============folder Jumplist================================={{{
#------------------------------------------------------
# go, gs

gh() { cd ~ && ls ;}
g/() { cd / && ls ;}
gr() { cd /run/media && ls ;}
gm() { cd /media && ls ;}
gM() { cd ~/Music && ls ;}
gD() { cd ~/Documents && ls ;}
gd() { cd ~/Downloads && ls ;}
ge() { cd ~/DL_Torrent && lst ;}
gp() { cd ~/Pictures && lst ;}
gP() { cd ~/Public && lst ;}
gS() { cd ~/.scripts && lst ;}
gw() { cd ~/Pictures/Wallpapers && lst ;}
gx() { cd ~/MA_Blackbox/iCloud && lst ;}
gu() { cd ~/Public/github_repository/shownotes && lst ;}
gi() { cd /tmp/fuseiso && lst ;}

#=============================================================}}}
#=============Clipboard and Upload============================{{{
#------------------------------------------------------
# DEMO: http://www.youtube.com/watch?v=fKP0FLp3uW0 (xclip)
# 	https://www.youtube.com/watch?v=Ww7Sl4d8F8A (pastebinit)
# DESC: copy/paste for linux machines (Mac style)

alias pbcopy='xclip -selection clipboard'	# copy to clipboard, ctrl+c, ctrl+shift+c
alias pbpaste='xclip -selection clipboard -o'	# paste from clipboard, ctrl+v, ctrl+shitt+v
alias pbselect='xclip -selection primary -o'	# paste from highlight, middle click, shift+insert
alias pbnoformatting='xclip -selection clipboard -o | xclip -selection clipboard'


# dump text from clipboard to pastebin server and copy link
alias pbclipboard2slexy='pbpaste | pastebinit -b "slexy.org" | pbcopy && echo "URL has been copied to clipboard" && pbpaste'
alias pbclipboard2sprungeus="pbpaste | curl -F 'sprunge=<-' http://sprunge.us | pbcopy && echo 'URL has been copied to clipboard' && pbpaste"
alias pbclipboard2ixio="pbpaste | curl -F 'f:1=<-' ix.io | pbcopy && echo 'URL has been copied to clipboard' && pbpaste"
alias pbclipboard2pastebindotcom='pbpaste | pastebinit -b "pastebin.com" | pbcopy && echo "URL has been copied to clipboard" && pbpaste'


alias pbuploadslexy='pbpaste | pastebinit -b "slexy.org" | pbcopy && echo "URL has been copied to clipboard" && pbpaste'

alias pbuploadsprungeus="cat "$@" | curl -F 'sprunge=<-' http://sprunge.us | pbcopy && echo 'URL has been copied to clipboard' && pbpaste"
alias pbuploadixio="cat "$1" | curl -F 'f:1=<-' ix.io | pbcopy && echo 'URL has been copied to clipboard' && pbpaste"



#=============================================================}}}
#=============Hardcoded Subtitles to Videos==================={{{
#------------------------------------------------------
# https://trac.ffmpeg.org/wiki/HowToBurnSubtitlesIntoVideo
# https://www.bunkus.org/videotools/mkvtoolnix/samples/
# install ttf-ms-fonts
# ffmpeg with --enable-libass

function to_ass() { ffmpeg -i "$1" "${1%.*}".ass ;} # srt --> ass
convert_to_srt() { ffmpeg -i "$1" "${1%.*}".srt ;} # ass --> srt

# The first 2 are alpha
# AABBGGRR = &HAABBGGRR

# usage: aliasname filename subtitles(srt/ass)
# convert_to_hardsubs() { ffmpeg -y -i "$1" -vf subtitles="$2":force_style="'Fontsize=35;FontName=DejaVu Serif,PrimaryColour=&H5014F0FF'" -codec:v libx264 -preset medium -crf 22 -codec:a aac -qscale:a 6 -strict experimental "${1%.*}"-hardsubs.mp4 ;}

convert_to_hardsubs() {
if [ $# -lt 2 ]
then
	echo -e "Use ffmpeg to hardcode subtitles into one movietrack"
	echo -e "\nUsage:\n$0 [file] [subtitle (srt/ass)] [fontsize (25)] [color code (yellow)] [fontname (dejavu sans mono)]"
	echo -e "\nexample:\n$0 file.mp4 file.srt"
	echo -e "$0 file.mp4 file.srt 30 5000FF14 Arial \n"
	echo -e "kml color code: http://www.zonums.com/gmaps/kml_color/"


	exit 1
fi

ffmpeg -y -i "$1" -vf subtitles="$2":force_style="'Fontsize=${3:-25},PrimaryColour=&H${4:-5014F0FF},FontName=${5:-DejaVu Sans Mono}'" -codec:v libx264 -preset medium -crf 22 -codec:a aac -qscale:a 6 -strict experimental "${1%.*}"-hardsubs.mp4
}

# 1min video testing
convert_to_testing() { ffmpeg -y -i "$1" -ss 00:05:00 -t 00:01:00 -vf subtitles="$2":force_style="'Fontsize=35;FontName=DejaVu Serif,PrimaryColour=&H5014F0FF'" -codec:v libx264 -preset medium -crf 22 -codec:a aac -qscale:a 6 -strict experimental "${1%.*}"-testing.mp4 ;}


# }}}
#=============concatenate Files==============================={{{
#------------------------------------------------------

# tutorial video: http://www.youtube.com/watch?v=eQoOk5Xbt3M
concat_pdf() {
  if [ $# -lt 1 ]; then
    echo -e "concatenate multiple pdf files into one single pdf"
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file1.pdf file2.pdf file3.pdf"
    echo -e "$0 *.pdf"
    echo -e "\nDependency: ghostscript"
    return 1
  fi
  gs -dBATCH -dNOPAUSE -sDEVICE=pdfwrite -sOutputFile="${1%.*}"-`date +'%F_%Hh%Ms%S'`_concat.pdf -f "$@"
}
split-document-pdf() {
  if [ $# -lt 3 ]; then
    echo -e "split pdf page range into one single pdf"
    echo -e "Usage: $0 <startpage> <endpage> <filename>"
    echo -e "\nExample:\n$0 2 7 file.pdf"
    echo -e "\nDependency: ghostscript"
    return 1
  fi
  gs -sDEVICE=pdfwrite -q -dNOPAUSE -dBATCH -sOutputFile="${3%.*}"_split_pages_"$1"_to_"$2".pdf -dFirstPage="$1" -dLastPage="$2" "$3"
}

concat-image-png() {
  if [ $# -lt 1 ]; then
    echo -e "concatenate multiple images into one single png"
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file1.jpg file2.png file3.jpeg"
    echo -e "$0 *.jpg"
    echo -e "$0 *.png"
    return 1
  fi
  convert -append "$@" "${1%.*}"_concat.png
}

concat-image-jpg() {
  if [ $# -lt 1 ]; then
    echo -e "concatenate multiple images into one single jpg"
    echo -e "Usage: $0 <filename>"
    echo -e "\nExample:\n$0 file1.jpg file2.png file3.jpeg"
    echo -e "$0 *.jpg"
    echo -e "$0 *.png"
    return 1
  fi
  convert -append "$@" "${1%.*}"_concat.jpg
}

#=============================================================}}}
#=============Concatenate Videos=============================={{{
#------------------------------------------------------
# DEMO: https://www.youtube.com/watch?v=jhv-2pNWfr4
# DESC: switch audio stream to different output (HDMI, Headphone, Speakers ...etc)
# REFF: http://askubuntu.com/a/18210
# LINK: http://quvi.sourceforge.net/

# DEMO: https://www.youtube.com/watch?v=EAWGFJoZXAU
concat-video-avi() {
  if [ $# -lt 1 ]; then
    echo -e "Usage: $0 <file>"
    echo -e "\nExample: \n$0 file1.avi file2.avi file3.avi"
    echo -e "$0 *.avi"
    echo -e "\nrequires package: transcode"
    return 1
  fi
  myArray=( "$@" )
  for arg in "${myArray[@]}"; do
    while [ ! -f "${arg%.*}"-movie.mp4 ]
    do
      avimerge -o "${1%.*}".concat.avi -i "$arg"
    done
done
}


# VIDEOCODEC="Xvid"
# AUDIOCODEC="MP3"
# for FIL in `ls *mp4 | sort` ; do
# avidemux2 --video-codec $VIDEOCODEC --audio-codec $AUDIOCODEC --force-alt-h264 --load "$FIL" --save ${FIL%.*}.avi --quit
# done


# concat_movie() {
# 	appendfile=$(echo "$@" | sed 's: : --append :g')
# 	avidemux2_cli --nogui --audio-codec copy --video-codec copy --output-format "${1##*.}" --load $(echo $appendfile) --save "${1%.*}"-appended."${1##*.}"
# }
#
concat-video-movie() {
	avidemux2_cli --nogui --force-alt-h264 \
	--audio-codec copy --video-codec copy --output-format "${1##*.}" \
	--load "$1" --append "$2" --append "$3" --append "$4" \
	--append "$5" --append "$6" --append "$7" --append "$8" \
	--save "${1%.*}"-appended."${1##*.}"
}

concat-video-mp4() {
	avidemux2_cli --nogui --force-alt-h264 \
	--audio-codec copy --video-codec copy --output-format "${1##*.}" \
	--load "$1" --append "$2" --append "$3" --append "$4" \
	--append "$5" --append "$6" --append "$7" --append "$8" \
	--save "${1%.*}"-appended."${1##*.}"
}


#=============================================================}}}
#=============extract Files==================================={{{
#------------------------------------------------------

# http://www.linuxjournal.com/content/tech-tip-extract-pages-pdf
extract_pdf() {
    if [ $# -lt 2 ]
    then
        echo -e "convert images into one single pdf"
        echo -e "\nUsage:\n$0 <input file> <startingpage> <endingpage>"
        echo -e "\nexample:\n$0 file.pdf 6"
        echo -e "\n$0 file.pdf 13 26"

        return 1
    fi

    gs -sDEVICE=pdfwrite -dNOPAUSE -dBATCH -dSAFER -dFirstPage="${2}" -dLastPage="${3:-$2}" -sOutputFile="${1%.pdf}"_p"${2}"-p"${3:-$2}".pdf "${1}"
}

#=============================================================}}}
#=============Muxing=========================================={{{
#------------------------------------------------------
mux_to_mkv() {
	# mkvmerge -o newfile.mkv part1.mkv +part2.mkv
	# appendfile=$echo ${@} | sed 's: : +:g')
	appendfile=$(echo "$@" | sed 's: : +:g')
        # appendfile=$(echo "$@" | sed 's/ /\ +/g')

	mkvmerge -o "${1%.*}".mux.mkv $(echo $appendfile)
	echo $appendfile

	}

#=============================================================}}}
#=============Custom seaches=================================={{{
gg-comic() { sitelist=$(echo "avaxhome.ws h33t.com mycomicpost.com bdcomics.bdgamers.net" \
	  	| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-cyberlocker() { sitelist=$(echo "hotfile.com rapidshare.com mediafire.com
	uploading.com depositfiles.com zshare.net filepost.com filefactory.com
	2shared.com zippyshare.com slingfile.com wuala.com filetram.com
	4shared.com rabidfiles.com" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-dojin() { sitelist=$(echo "hentairules.net fakku.net hentaifromhell.net" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-icons() { sitelist=$(echo "iconseeker.com iconarchive.com iconfinder.com
	deviantart.com veryicon.com iconspedia.com" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-keygen() { sitelist=$(echo "crack.ms/cracks/crack.ms?id" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-music() { url=$(echo "https://encrypted.google.com/search?hl=en&q=
	intitle:index.of+mp3+"$@"+-html+-htm+-txt"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-packages() { sitelist=$(echo "sourceforge.net github.com archlinux.org/packages
	freecode.com/projects gnome.org/extension python.org/pypi gentoo.org/package" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-pastebin() { sitelist=$(echo "pastebin.com paste2.org pastie.org snipt.net
	heypasteit.com/clip pastee.org shell-fu.org commandlinefu.com catonmat.net
	linuxconfig.net github.com bitbucket.org slexy.org stackoverflow.com
	askubuntu.com superuser.com dotfiles.org dotshare.it gitorious.org
	serverfault.com wikia.com stackexchange.com" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-piratebay() { url=$(echo "http://thepiratebay.org/search/$@" \
		| sed 's/ /+/g'); $BROWSER $url; }
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-reader() { url=$(echo "https://encrypted.google.com/reader/view/#search/$@" \
		| sed 's/ /+/g'); $BROWSER $url; }
gg-search() { url=$(echo "https://encrypted.google.com/search?hl=en&q=$@" \
		| sed 's/ /+/g'); $BROWSER $url; }
gg-serial() { sitelist=$(echo "freeserials.com/serials/download.php?id= serials.ws/d.php?n" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-torrent() { sitelist=$(echo "eztv.it thepiratebay.se torrentzap.com fenopy.com
	torrindex.com h33t.com tokyotosho.info nyaa.eu" \
		| sed 's/ /\+OR\+site\:/g')
	url=$(echo "https://encrypted.google.com/search?hl=en&q=$@+site:$sitelist"\
		| sed 's/ /+/g'); $BROWSER $url; }
gg-translate() {
	$BROWSER http://translate.google.com/#auto/en/"$*" ;}

#}}}
#=============internet Videos - Castalba.tv==================={{{
#------------------------------------------------------
# http://castalba.tv/channels
# Animation, Documentary, Entertainment, Sports, News

# sample of fail capture links
#rtmpdump -r "rtmp://live.castalba.tv/calive" -a "calive" -f "LNX 11,2,202,243" -W "http://static.castalba.tv/player.swf" -p "http://castalba.tv/channel/6768" -y "174956" -o 174956.flv

CTVPLAYER=mplayer
ctv-news-aljazeera() { rtmpdump -v -r "rtmp://aljazeeraflashlivefs.fplive.net/aljazeeraflashlive-live" \
	-a "aljazeeraflashlive-live" \
	-f "LNX 11,2,202,261" \
	-W "http://static.castalba.tv/player.swf" \
	-p "http://castalba.tv/channel/4182" \
	-y "aljazeera_eng_low" | "$CTVPLAYER" - ;}

#}}}
#=============More Functions=================================={{{
function paclist() {
  # Source: https://bbs.archlinux.org/viewtopic.php?id=93683
  LC_ALL=C pacman -Qei $(pacman -Qu | cut -d " " -f 1) | \
    awk 'BEGIN {FS=":"} /^Name/{printf("\033[1;36m%s\033[1;37m", $2)} /^Description/{print $2}'
}

date-global() {
# use tzselect to find timezone listing
    local SHOWTIMEZONE="$(
    alias date='date +"%a %D %l:%M %p"'
    echo "Current Location:" "$(date)"
    echo "USA LosAngeles:" "$(TZ='America/Los_Angeles' date)"
    echo "Canada Alberta:" "$(TZ='America/Edmonton' date)"
    echo "USA NewYork:" "$(TZ='America/New_York' date)"
    echo "EU London:" "$(TZ='Europe/London' date)"
    echo "Bangladesh Dhaka:" "$(TZ='Asia/Dhaka' date)"
    echo "China Xinjiang:" "$(TZ='Asia/Urumqi' date)"
    echo "Vietnam Saigon:" "$(TZ='Asia/Ho_Chi_Minh' date)"
    echo "China Beijing:" "$(TZ='Asia/Shanghai' date)"
    echo "HK HongKong:" "$(TZ='Asia/Hong_Kong' date)"
    echo "Japan Tokyo:" "$(TZ='Asia/Tokyo' date)"
    )"
    echo "$SHOWTIMEZONE" | column -t
}
function auto-ls () {
	emulate -L zsh;
# explicit sexy ls'ing as aliases arent honored in here.
	hash gls >/dev/null 2>&1 && CLICOLOR_FORCE=1 gls -aFh --color --group-directories-first || ls
}
chpwd_functions=( auto-ls $chpwd_functions )


function ranger-cd {
    tempfile="$(mktemp -t tmp.XXXXXX)"
    /usr/bin/ranger --choosedir="$tempfile" "${@:-$(pwd)}"
    test -f "$tempfile" &&
    if [ "$(cat -- "$tempfile")" != "$(echo -n `pwd`)" ]; then
        cd -- "$(cat "$tempfile")"
    fi
    rm -f -- "$tempfile"
}
# call nvim help page from shell prompt
    function vimhelp { nvim +":h $1" +'wincmd o' +'nnoremap q :q!<CR>' ;}

# type read me to read the read regardless of exstinstion or case
    function readme() {
	for readme in {readme,README}.{md,MD,markdown,txt,TXT,mkd}; do
	    if [[ -f "$readme" ]]; then
		less $readme
		    fi
		    done
    }
# Compile and execute a C source on the fly
    csource() {
	[[ $1 ]]    || { echo "Missing operand" >&2; return 1; }
	[[ -r $1 ]] || { printf "File %s does not exist or is not readable\n" "$1" >&2; return 1; }
	local output_path=${TMPDIR:-/tmp}/${1##*/};
	gcc "$1" -o "$output_path" && "$output_path";
	rm "$output_path";
	return 0;
    }
# uses Pv to have a progress bar
    pvcp() {
	SOURCE=$1
	    if [ -d $2 ]
		then
		    DESTINATION=$2/`basename $SOURCE`
	    else
		DESTINATION=$2
		    fi
		    pv ${SOURCE} | > ${DESTINATION}
    }

    cpv() {
	rsync -pogbr -hhh --backup-dir=/tmp/rsync -e /dev/null --progress "$@"
    }

    Calc() {
	if which python2 &>/dev/null; then
	    python2 -ic "from __future__ import division; from math import *; from random import *"
		elif which python3 &>/dev/null; then
		python3 -ic "from math import *; import cmath"
		elif which bc &>/dev/null; then
		bc -q -l
	else
	    echo "Requires python2, python3 or bc for calculator features"
		fi
    }
    rezsh() {
	local cache="$ZSH_CACHE_DIR"
	    autoload -U compinit zrecompile
	    compinit -i -d "$cache/zcomp-$HOST"

	    for f in ~/.zshrc "$cache/zcomp-$HOST"; do
		zrecompile -p $f && command rm -f $f.zwc.old
		    done

# Use $SHELL if available; remove leading dash if login shell
		    [[ -n "$SHELL" ]] && exec ${SHELL#-} || exec zsh
    }

# Better find(1)
    function ff() {
	find . -iname "*${1:-}*"
    }
# show file access permission
# http://unix.stackexchange.com/a/46921
    filep() { stat --format '%a %n' "$@" ;}
# display mime of file application/zip, application/x-tar
    fileT() { file --mime-type -b "$@" ;}


    fix-pman() {
	sudo pacman "$@"  \
	    --log /dev/null   \

	    --force           \
	    --nodeps          \
	    --needed
    }
# Color Man pages
    man() {
	env LESS_TERMCAP_mb=$'\E[01;31m' \
			    LESS_TERMCAP_md=$'\E[01;31m' \
			    LESS_TERMCAP_me=$'\E[0m' \
			    LESS_TERMCAP_se=$'\E[0m' \
			    LESS_TERMCAP_so=$'\E[01;44;33m' \
			    LESS_TERMCAP_ue=$'\E[0m' \
			    LESS_TERMCAP_us=$'\E[01;32m' \
			    man "$@"
    }
    bak() {
	if [[ -e "$1" ]]; then
	    echo "Found: $1"
		mv "${1%.*}"{,.bak}
	elif [[ -e "$1.bak" ]]; then
	    echo "Found: $1.bak"
	    mv "$1"{.bak,}
	fi
    }

# DESCRIPTION
#    Records sound from microphone and converts it to mp3
    rec() {
	local ts
	    ts=`date +%s`
	    arecord -f cd -t wav /tmp/$ts.wav
	    ffmpeg -i /tmp/$ts.wav -codec:a libmp3lame -qscale:a 0 /tmp/$ts.mp3
	    echo -n /tmp/$ts.mp3 | xclip
    }

# view markdown as manpages
# http://blog.metamatt.com/blog/2013/01/09/previewing-markdown-files-from-the-terminal/
mdless(){ pandoc -s -f markdown -t man "$*" | groff -T utf8 -man | less ;}

#
ranger() {
    if [ -z "$RANGER_LEVEL" ]; then
        /usr/bin/ranger "$@"
    else
        exit
    fi
}

# search commandlinefu.com
cmdfu() { curl "http://www.commandlinefu.com/commands/matching/$(echo "$@" \
	| sed 's/ /-/g')/$(echo -n $@ | base64)/plaintext" ;}

# display one random command from commandlinefu.com
cmdfu-random() { echo -e "`curl -sL http://www.commandlinefu.com/commands/random/json|sed -re 's/.*,"command":"(.*)","summary":"([^"]+).*/\\x1b[1;32m\2\\n\\n\\x1b[1;33m\1\\x1b[0m/g'`\n" ;}
wget-extension() {
  if [ $# -lt 2 ]; then
    echo -e "Download all files with specific extension on a webpage"
    echo -e "\nUsage:   $0 <file_extension> <url>"
    echo -e "\nExample: $0 mp3 http://example.com/files/"
    echo -e "\nGoogle: http://lmgtfy.com/?q=intitle%3Aindex.of+mp3+-html+-htm+-php+-asp+-txt+-pls+madonna"
    return 1
  fi

  savepath=~/Downloads
  outputdir_name=$(echo "$2" | rev | cut -d\/ -f2 | rev)

  mkdir -pv "$savepath/$outputdir_name"
  cd "$savepath/$outputdir_name" && wget -r -l1 -H -t1 -nd -N -np -A "$1" -erobots=off "$2"
}

function ua() {
  local usage=\
"Archive files and directories using a given compression algorithm.

Usage:   $0 <format> <files>
Example: $0 tbz PKGBUILD

Supported archive formats are:
7z, bz2, gz, lzma, lzo, rar, tar, tbz (tar.bz2), tgz (tar.gz),
tlz (tar.lzma), txz (tar.xz), tZ (tar.Z), xz, Z, zip, and zst."

  if [[ $# -lt 2 ]]; then
    print -u2 -- "$usage"
    return 1
  fi

  local ext="$1"
  local input="${2:a}"

  shift

  if [[ ! -e "$input" ]]; then
    print -u2 -- "$input not found"
    return 1
  fi

  # generate output file name
  local output
  if [[ $# -gt 1 ]]; then
    output="${input:h:t}"
  elif [[ -f "$input" ]]; then
    output="${input:r:t}"
  elif [[ -d "$input" ]]; then
    output="${input:t}"
  fi

  # if output file exists, generate a random name
  if [[ -f "${output}.${ext}" ]]; then
    output=$(mktemp "${output}_XXX") && rm "$output" || return 1
  fi

  # add extension
  output="${output}.${ext}"

  # safety check
  if [[ -f "$output" ]]; then
    print -u2 -- "output file '$output' already exists. Aborting"
    return 1
  fi

  case "$ext" in
    7z)           7z u                        "${output}"   "${@}" ;;
    bz2)          bzip2 -vcf                  "${@}" > "${output}" ;;
    gz)           gzip -vcf                   "${@}" > "${output}" ;;
    lzma)         lzma -vc -T0                "${@}" > "${output}" ;;
    lzo)          lzop -vc                    "${@}" > "${output}" ;;
    rar)          rar a                       "${output}"   "${@}" ;;
    tar)          tar -cvf                    "${output}"   "${@}" ;;
    tbz|tar.bz2)  tar -cvjf                   "${output}"   "${@}" ;;
    tgz|tar.gz)   tar -cvzf                   "${output}"   "${@}" ;;
    tlz|tar.lzma) XZ_OPT=-T0 tar --lzma -cvf  "${output}"   "${@}" ;;
    txz|tar.xz)   XZ_OPT=-T0 tar -cvJf        "${output}"   "${@}" ;;
    tZ|tar.Z)     tar -cvZf                   "${output}"   "${@}" ;;
    xz)           xz -vc -T0                  "${@}" > "${output}" ;;
    Z)            compress -vcf               "${@}" > "${output}" ;;
    zip)          zip -rull                   "${output}"   "${@}" ;;
    zst)          zstd -c -T0                 "${@}" > "${output}" ;;
    *) print -u2 -- "$usage"; return 1 ;;
  esac
}
#==========================================================}}}
    
